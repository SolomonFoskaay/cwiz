"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.zipHardhat = void 0;
const jszip_1 = __importDefault(require("jszip"));
const print_1 = require("./print");
const solidity_version_json_1 = __importDefault(require("./solidity-version.json"));
const format_lines_1 = require("./utils/format-lines");
const hardhatConfig = (upgradeable) => `\
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";
${upgradeable ? `import "@openzeppelin/hardhat-upgrades";` : ''}

const config: HardhatUserConfig = {
  solidity: {
    version: "${solidity_version_json_1.default}",
    settings: {
      optimizer: {
        enabled: true,
      },
    },
  },
};

export default config;
`;
const tsConfig = `\
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true
  }
}
`;
const gitIgnore = `\
node_modules
.env
coverage
coverage.json
typechain
typechain-types

#Hardhat files
cache
artifacts
`;
const test = (c, opts) => {
    return (0, format_lines_1.formatLinesWithSpaces)(2, ...(0, format_lines_1.spaceBetween)(getImports(c), getTestCase(c)));
    function getTestCase(c) {
        return [
            `describe("${c.name}", function () {`,
            [
                'it("Test contract", async function () {',
                (0, format_lines_1.spaceBetween)([
                    `const ContractFactory = await ethers.getContractFactory("${c.name}");`,
                ], [
                    `const instance = await ${c.upgradeable ? 'upgrades.deployProxy(ContractFactory)' : 'ContractFactory.deploy()'};`,
                    'await instance.deployed();'
                ], getContractSpecificExpects()),
                '});'
            ],
            '});',
        ];
    }
    function getImports(c) {
        return [
            'import { expect } from "chai";',
            `import { ${getHardhatPlugins(c).join(', ')} } from "hardhat";`,
        ];
    }
    function getContractSpecificExpects() {
        if (opts !== undefined) {
            switch (opts.kind) {
                case 'ERC20':
                case 'ERC721':
                    return [`expect(await instance.name()).to.equal("${opts.name}");`];
                case 'ERC1155':
                    return [`expect(await instance.uri(0)).to.equal("${opts.uri}");`];
                case 'Governor':
                case 'Custom':
                    break;
                default:
                    throw new Error('Unknown ERC');
            }
        }
        return [];
    }
};
const script = (c) => `\
import { ${getHardhatPlugins(c).join(', ')} } from "hardhat";

async function main() {
  const ContractFactory = await ethers.getContractFactory("${c.name}");

  const instance = await ${c.upgradeable ? 'upgrades.deployProxy(ContractFactory)' : 'ContractFactory.deploy()'};
  await instance.deployed();

  console.log(\`${c.upgradeable ? 'Proxy' : 'Contract'} deployed to \${instance.address}\`);
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
`;
const readme = `\
# Sample Hardhat Project

This project demonstrates a basic Hardhat use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that deploys that contract.

## Installing dependencies

\`\`\`
npm install
\`\`\`

## Testing the contract

\`\`\`
npm test
\`\`\`

## Deploying the contract

You can target any network from your Hardhat config using:

\`\`\`
npx hardhat run --network <network-name> scripts/deploy.ts
\`\`\`
`;
function getHardhatPlugins(c) {
    let plugins = ['ethers'];
    if (c.upgradeable) {
        plugins.push('upgrades');
    }
    return plugins;
}
async function zipHardhat(c, opts) {
    const zip = new jszip_1.default();
    const { default: packageJson } = c.upgradeable ? await Promise.resolve().then(() => __importStar(require("./environments/hardhat/upgradeable/package.json"))) : await Promise.resolve().then(() => __importStar(require("./environments/hardhat/package.json")));
    packageJson.license = c.license;
    const { default: packageLock } = c.upgradeable ? await Promise.resolve().then(() => __importStar(require("./environments/hardhat/upgradeable/package-lock.json"))) : await Promise.resolve().then(() => __importStar(require("./environments/hardhat/package-lock.json")));
    packageLock.packages[''].license = c.license;
    zip.file(`contracts/${c.name}.sol`, (0, print_1.printContract)(c));
    zip.file('test/test.ts', test(c, opts));
    zip.file('scripts/deploy.ts', script(c));
    zip.file('.gitignore', gitIgnore);
    zip.file('hardhat.config.ts', hardhatConfig(c.upgradeable));
    zip.file('package.json', JSON.stringify(packageJson, null, 2));
    zip.file(`package-lock.json`, JSON.stringify(packageLock, null, 2));
    zip.file('README.md', readme);
    zip.file('tsconfig.json', tsConfig);
    return zip;
}
exports.zipHardhat = zipHardhat;
//# sourceMappingURL=zip-hardhat.js.map